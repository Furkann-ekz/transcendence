Her dosya ile yenisinin arasında 6 satır boşluk olacak. Ardından "<dosya_adı>:" ve bir boşluk daha geliyor ve dosya içeriği yer alıyor. Bu şekilde göndereceğim.

Makefile:

# Makefile for ft_transcendence project management


# .PHONY, bu hedeflerin birer dosya olmadığını, komut olduğunu belirtir.

.PHONY: all up stop down clean db links start check-env


# 'make' komutu tek başına çalıştırıldığında 'up' hedefini çağırır.

all: up


# YENİ VE GELİŞMİŞ "UP" KOMUTU

# Projeyi sıfırdan kurar, başlatır ve veritabanını sıfırlar.

up: check-env clean

    @echo "--- Starting containers with a fresh build... ---"

    docker compose up --build -d

    @echo "--- Waiting for containers to initialize... ---"

    @sleep 3 # Konteynerlerin tam olarak başlaması için 3 saniye bekle

    @echo "--- Initializing database... ---"


# Arka planda çalışan konteynerleri sadece durdurur (silmez).

stop:

    @echo "--- Stopping running containers... ---"

    docker compose stop


# Projeyi durdurur ve docker-compose tarafından yönetilen her şeyi temizler.

down:

    @echo "--- Stopping and removing containers, networks, and volumes... ---"

    docker compose down --volumes --remove-orphans


# Projeyle ilgili olabilecek tüm "hayalet" konteynerleri zorla temizler.

clean: down

    @echo "--- Forcibly removing any lingering containers... ---"

    @docker ps -a -q --filter "name=transcendence_backend" | xargs -r docker rm -f || true

    @docker ps -a -q --filter "name=transcendence_frontend" | xargs -r docker rm -f || true


# Veritabanını sıfırlar (tüm verileri siler).

db:

    @echo "--- Resetting database inside the container... ---"

    docker compose exec backend npx prisma migrate reset --force


migrate:

    @echo "--- Applying new migrations inside the container... ---"

    docker compose exec backend npx prisma migrate dev


# Ağ ve yerel erişim linklerini gösterir.

links:

    @echo "for network: http://$$(hostname -I | awk '{print $$1}'):5173"

    @echo "for local:   http://localhost:5173"


# YENİ YARDIMCI HEDEF: .env dosyasını kontrol eder ve gerekirse oluşturur.

check-env:

    @if [ ! -f backend/.env ]; then \

        echo "--- .env file not found. Creating from .env.example... ---"; \

        cp backend/.env.example backend/.env; \

    fi


# Projeyi ilk kez kurmak için host makinedeki bağımlılıkları yükler (IDE desteği için).

start:

    @echo "Installing backend dependencies on host..."

    (cd backend && npm install)

    @echo "Installing frontend dependencies on host..."

    (cd frontend && npm install)

    @echo "Host setup complete! You can now run 'make up'."






docker-compose.yml:

services:

  backend:

    build:

      context: ./backend

      dockerfile: Dockerfile

    container_name: transcendence_backend

    ports:

      - "3000:3000"

    volumes:

      - ./backend:/usr/src/app

      - /usr/src/app/node_modules

    networks:

      - transcendence_network


  frontend:

    build:

      context: ./frontend

      dockerfile: Dockerfile

    container_name: transcendence_frontend

    ports:

      - "5173:5173"

    volumes:

      - ./frontend:/usr/src/app

      - /usr/src/app/node_modules

    depends_on:

      - backend

    networks:

      - transcendence_network


networks:

  transcendence_network:

    driver: bridge






backend/api/auth.routes.js:

// backend/api/auth.routes.js

const bcrypt = require('bcrypt');

const jwt = require('jsonwebtoken');

const prisma = require('../prisma/db');

const SALT_ROUNDS = 10;

const JWT_SECRET = process.env.JWT_SECRET;


async function authRoutes(fastify, options) {

    fastify.post('/register', async (request, reply) => {

        const { email, name, password } = request.body;

        if (!email || !password) return reply.code(400).send({ error: 'Email and password are required' });

        try {

            const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);

            const user = await prisma.user.create({ data: { email, name, password: hashedPassword } });

            const { password: _, ...userWithoutPassword } = user;

            return reply.code(201).send(userWithoutPassword);

        } catch (error) {

            if (error.code === 'P2002') return reply.code(409).send({ error: 'This email is already registered' });

            fastify.log.error(error);

            return reply.code(500).send({ error: 'Could not register user' });

        }

    });


    fastify.post('/login', async (request, reply) => {

        const { email, password } = request.body;

        if (!email || !password) return reply.code(400).send({ error: 'Email and password are required' });

        try {

            const user = await prisma.user.findUnique({ where: { email } });

            const isPasswordMatch = user ? await bcrypt.compare(password, user.password) : false;

            if (!user || !isPasswordMatch) return reply.code(401).send({ error: 'Invalid credentials' });

            const token = jwt.sign({ userId: user.id, email: user.email }, JWT_SECRET, { expiresIn: '1h' });

            return { token };

        } catch (error) {

            fastify.log.error(error);

            return reply.code(500).send({ error: 'Internal Server Error' });

        }

    });

}

module.exports = authRoutes;






backend/api/users.routes.js:

// backend/api/users.routes.js

const prisma = require('../prisma/db');

const authenticate = require('../middleware/authenticate');


async function userRoutes(fastify, options) {

    // Mevcut: Sadece kendi profilini getirir.

    fastify.get('/profile', { preHandler: [authenticate] }, async (request, reply) => {

        const userProfile = await prisma.user.findUnique({

            where: { id: request.user.userId },

            select: { id: true, email: true, name: true, createdAt: true, wins: true, losses: true },

        });

        if (!userProfile) return reply.code(404).send({ error: 'User not found' });

        return userProfile;

    });


    // Mevcut: Belirli bir kullanıcının halka açık profilini ID ile getirir.

    fastify.get('/users/:id', { preHandler: [authenticate] }, async (request, reply) => {

        const userId = parseInt(request.params.id, 10);

        if (isNaN(userId)) {

            return reply.code(400).send({ error: 'Invalid user ID' });

        }


        try {

            const user = await prisma.user.findUnique({

                where: { id: userId },

                select: { // Sadece güvenli ve halka açık bilgileri döndür

                    id: true,

                    name: true,

                    createdAt: true,

                    // --- YENİ EKLENEN ALANLAR ---

                    wins: true,

                    losses: true

                    // -------------------------

                }

            });


            if (!user) {

                return reply.code(404).send({ error: 'User not found' });

            }

            return user;

        } catch (error) {

            fastify.log.error(error);

            return reply.code(500).send({ error: 'Internal Server Error' });

        }

    });


    // --- YENİ EKLENEN YOL ---

    // Belirli bir kullanıcının son 10 maçını getirir.

    fastify.get('/users/:id/matches', { preHandler: [authenticate] }, async (request, reply) => {

        const userId = parseInt(request.params.id, 10);

        if (isNaN(userId)) {

            return reply.code(400).send({ error: 'Invalid user ID' });

        }

        try {

            const matches = await prisma.match.findMany({

                where: {

                    OR: [

                        { player1Id: userId },

                        { player2Id: userId }

                    ]

                },

                orderBy: {

                    createdAt: 'desc'

                },

                take: 10,

                include: { // Rakip bilgilerini de almak için

                    player1: { select: { id: true, name: true } },

                    player2: { select: { id: true, name: true } }

                }

            });

            return matches;

        } catch (error) {

            fastify.log.error(error);

            return reply.code(500).send({ error: 'Internal Server Error' });

        }

    });

}


module.exports = userRoutes;






backend/middleware/authenticate.js:

// backend/middleware/authenticate.js

const jwt = require('jsonwebtoken');

const JWT_SECRET = process.env.JWT_SECRET;


async function authenticate(request, reply) {

    try {

        const authHeader = request.headers.authorization;

        if (!authHeader || !authHeader.startsWith('Bearer ')) {

            return reply.code(401).send({ error: 'Unauthorized: No token provided' });

        }

        const token = authHeader.split(' ')[1];

        const decoded = jwt.verify(token, JWT_SECRET);

        request.user = decoded;

    } catch (error) {

        return reply.code(401).send({ error: 'Unauthorized: Invalid token' });

    }

}

module.exports = authenticate;






backend/prisma/db.js:

// backend/prisma/db.js

const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

module.exports = prisma;






backend/prisma/schema.prisma:

// backend/prisma/schema.prisma


generator client {

  provider = "prisma-client-js"

}


datasource db {

  provider = "sqlite"

  url      = env("DATABASE_URL")

}


model User {

  id               Int      @id @default(autoincrement())

  createdAt        DateTime @default(now())

  email            String   @unique

  name             String?

  password         String

  wins             Int      @default(0)

  losses           Int      @default(0)

  matchesAsPlayer1 Match[]  @relation("Player1Matches")

  matchesAsPlayer2 Match[]  @relation("Player2Matches")

  matchesAsPlayer3 Match[]  @relation("Player3Matches")

  matchesAsPlayer4 Match[]  @relation("Player4Matches")

  // Bu alan, aşağıdaki Match.winner ile eşleşir

  wonMatches       Match[]  @relation("WinnerMatches")

}


model Match {

  id                 Int      @id @default(autoincrement())

  createdAt          DateTime @default(now())

  durationInSeconds  Int

  mode               String

  player1Id          Int

  player3Id          Int?

  player2Id          Int

  player4Id          Int?

  player1            User     @relation("Player1Matches", fields: [player1Id], references: [id])

  player3            User?    @relation("Player3Matches", fields: [player3Id], references: [id])

  player2            User     @relation("Player2Matches", fields: [player2Id], references: [id])

  player4            User?    @relation("Player4Matches", fields: [player4Id], references: [id])

  team1Score         Int

  team2Score         Int

  winnerTeam         Int

  wasForfeit         Boolean  @default(false)

  

  winnerId           Int

  // DÜZELTME: Bu alana, User.wonMatches ile aynı olan ilişki adı eklendi

  winner             User     @relation("WinnerMatches", fields: [winnerId], references: [id])


  team1Hits          Int      @default(0)

  team1Misses        Int      @default(0)

  team2Hits          Int      @default(0)

  team2Misses        Int      @default(0)

}






backend/websockets/chatHandler.js:

// backend/websockets/chatHandler.js

function chatHandler(io, socket, onlineUsers) {

    socket.on('chat message', (msg) => {

        const messageObject = {

            type: 'public',

            sender: socket.user.name || socket.user.email,

            content: msg

        };

        io.emit('chat message', messageObject);

    });

    

    socket.on('private message', ({ recipientId, message }) => {

        const recipientSocket = io.sockets.sockets.get(onlineUsers.get(recipientId)?.socketId);

        if (recipientSocket) {

            const messageObject = {

                type: 'private',

                sender: socket.user.name || socket.user.email,

                content: message

            };

            recipientSocket.emit('chat message', messageObject); // Alıcıya gönder

            socket.emit('chat message', messageObject); // Gönderene de gönder

        }

    });

}

module.exports = chatHandler;






backend/websockets/gameHandler.js:

const prisma = require('../prisma/db');


function shuffleArray(array) {

    for (let i = array.length - 1; i > 0; i--) {

        const j = Math.floor(Math.random() * (i + 1));

        [array[i], array[j]] = [array[j], array[i]];

    }

}


async function updatePlayerStats(playerIds, outcome) {

    const fieldToIncrement = outcome === 'win' ? 'wins' : 'losses';

    try {

        await prisma.user.updateMany({

            where: { id: { in: playerIds } },

            data: { [fieldToIncrement]: { increment: 1 } }

        });

        console.log(`Stats updated for players ${playerIds}. Outcome: ${outcome}`);

    } catch (error) {

        console.error("Failed to update player stats:", error);

    }

}


async function saveMatch(game, winnerTeam, wasForfeit = false) {

    const { players, gameState, mode } = game;

    const team1 = players.filter(p => p.team === 1);

    const team2 = players.filter(p => p.team === 2);

    

    // 1v1 ve 2v2 modları için temsili oyuncu ID'lerini al

    const player1Id = team1[0].id;

    const player2Id = team2[0].id;


    try {

        await prisma.match.create({

            data: {

                mode: mode,

                durationInSeconds: 0, // Bu özelliği şimdilik basitleştirelim

                player1Id: player1Id,

                player3Id: team1[1]?.id, // 2v2 ise ikinci oyuncu, değilse null

                player2Id: player2Id,

                player4Id: team2[1]?.id, // 2v2 ise ikinci oyuncu, değilse null


                // --- DÜZELTME: Alan isimleri şema ile eşleştirildi ---

                player1Score: gameState.team1Score,

                player2Score: gameState.team2Score,

                winnerId: winnerTeam === 1 ? player1Id : player2Id,

                // ----------------------------------------------------


                wasForfeit: wasForfeit,


                // hit/miss istatistikleri şimdilik eklenmedi, basit tutuyoruz

                team1Hits: 0,

                team1Misses: 0,

                team2Hits: 0,

                team2Misses: 0

            }

        });

        console.log("Maç başarıyla kaydedildi.");

    } catch (error) { 

        console.error("Maç kaydedilemedi:", error); 

    }

}


// --- ANA OYUN DÖNGÜSÜ ---


function startGameLoop(room, players, io, mode, gameConfig) {

    const { canvasSize, paddleSize, paddleThickness } = gameConfig;

    const WINNING_SCORE = 5;

    const BALL_RADIUS = 10;

    

    const game = { players, mode, gameState: {}, intervalId: null };


    let gameState = {

        ballX: canvasSize / 2, ballY: canvasSize / 2, ballSpeedX: 6, ballSpeedY: 6,

        team1Score: 0, team2Score: 0,

        players: players.map(p => ({ ...p }))

    };

    game.gameState = gameState;


    const intervalId = setInterval(async () => {

        gameState.ballX += gameState.ballSpeedX;

        gameState.ballY += gameState.ballSpeedY;


        // DÜZELTİLMİŞ ÇARPIŞMA MANTIĞI

        gameState.players.forEach(p => {

            if (p.position === 'left' || p.position === 'right') {

                const paddleEdgeX = (p.position === 'left') ? paddleThickness : canvasSize - paddleThickness;

                const ballEdgeX = (p.position === 'left') ? gameState.ballX - BALL_RADIUS : gameState.ballX + BALL_RADIUS;

                if (((p.position === 'left' && ballEdgeX <= paddleEdgeX && gameState.ballSpeedX < 0) || (p.position === 'right' && ballEdgeX >= paddleEdgeX && gameState.ballSpeedX > 0)) &&

                    (gameState.ballY > p.y && gameState.ballY < p.y + paddleSize)) {

                    gameState.ballSpeedX = -gameState.ballSpeedX;

                }

            } else {

                const paddleEdgeY = (p.position === 'top') ? paddleThickness : canvasSize - paddleThickness;

                const ballEdgeY = (p.position === 'top') ? gameState.ballY - BALL_RADIUS : gameState.ballY + BALL_RADIUS;

                if (((p.position === 'top' && ballEdgeY <= paddleEdgeY && gameState.ballSpeedY < 0) || (p.position === 'bottom' && ballEdgeY >= paddleEdgeY && gameState.ballSpeedY > 0)) &&

                    (gameState.ballX > p.x && gameState.ballX < p.x + paddleSize)) {

                    gameState.ballSpeedY = -gameState.ballSpeedY;

                }

            }

        });


        // Skorlama mantığı

        let scored = false;

        let scoringTeam = null;

        if (gameState.ballX - BALL_RADIUS < 0) { const player = gameState.players.find(p => p.position === 'left'); scoringTeam = player.team === 1 ? 2 : 1; scored = true; } 

        else if (gameState.ballX + BALL_RADIUS > canvasSize) { const player = gameState.players.find(p => p.position === 'right'); scoringTeam = player.team === 1 ? 2 : 1; scored = true; }

        if (mode === '2v2') {

            if (gameState.ballY - BALL_RADIUS < 0) { const player = gameState.players.find(p => p.position === 'top'); scoringTeam = player.team === 1 ? 2 : 1; scored = true; } 

            else if (gameState.ballY + BALL_RADIUS > canvasSize) { const player = gameState.players.find(p => p.position === 'bottom'); scoringTeam = player.team === 1 ? 2 : 1; scored = true; }

        } else { if (gameState.ballY - BALL_RADIUS <= 0 || gameState.ballY + BALL_RADIUS >= canvasSize) { gameState.ballSpeedY = -gameState.ballSpeedY; } }

        

        if (scored) {

            if(scoringTeam === 1) gameState.team1Score++; else gameState.team2Score++;

            io.to(room).emit('gameStateUpdate', gameState);


            if (gameState.team1Score >= WINNING_SCORE || gameState.team2Score >= WINNING_SCORE) {

                clearInterval(intervalId);

                const winners = players.filter(p => p.team === scoringTeam);

                const losers = players.filter(p => p.team !== scoringTeam);

                

                await updatePlayerStats(winners.map(p => p.id), 'win');

                await updatePlayerStats(losers.map(p => p.id), 'loss');

                await saveMatch(game, scoringTeam, false);


                io.to(room).emit('gameOver', { winners, losers, reason: 'score' });

                const playerSockets = players.map(p => io.sockets.sockets.get(p.socketId)).filter(Boolean);

                playerSockets.forEach(sock => { sock.leave(room); sock.gameRoom = null; });

                return; 

            }

            

            gameState.ballX = gameConfig.canvasSize / 2;

            gameState.ballY = gameConfig.canvasSize / 2;

            gameState.ballSpeedX = -gameState.ballSpeedX;

        }

        

        if (!scored) {

            io.to(room).emit('gameStateUpdate', gameState);

        }

    }, 1000 / 60);


    game.intervalId = intervalId;


    const gameStartPayload = {

        players: players.map(p => ({id: p.id, name: p.name, email: p.email, position: p.position, team: p.team})),

        mode,

        ...gameConfig

    };

    io.to(room).emit('gameStart', gameStartPayload);

    return game;

}


function gameHandler(io, socket, state, payload) {

    const { mode } = payload;

    if (!mode || !state.waitingPlayers[mode]) return;


    const isInAnyPool = Object.values(state.waitingPlayers).some(pool => pool.some(p => p.id === socket.id));

    if (isInAnyPool) {

        console.log(`[Matchmaking] ${socket.user.email} zaten bir bekleme havuzunda.`);

        return;

    }


    const pool = state.waitingPlayers[mode];

    pool.push(socket);

    console.log(`[Matchmaking] ${socket.user.email} -> ${mode} havuzuna eklendi. (Havuzda ${pool.length} kişi var)`);

    pool.forEach(p => p.emit('updateQueue', { queueSize: pool.length, requiredSize: mode === '1v1' ? 2 : 4 }));


    let playerSockets;

    let players;

    const gameConfig = { canvasSize: 800, paddleSize: 100, paddleThickness: 15 };


    if (mode === '1v1' && pool.length >= 2) {

        playerSockets = pool.splice(0, 2);

        const [p1, p2] = playerSockets;

        players = [

            { ...p1.user, socketId: p1.id, position: 'left', team: 1, x: 0, y: (gameConfig.canvasSize / 2) - (gameConfig.paddleSize / 2) },

            { ...p2.user, socketId: p2.id, position: 'right', team: 2, x: gameConfig.canvasSize - gameConfig.paddleThickness, y: (gameConfig.canvasSize / 2) - (gameConfig.paddleSize / 2) }

        ];

    }


    if (mode === '2v2' && pool.length >= 4) {

        playerSockets = pool.splice(0, 4);

        shuffleArray(playerSockets);

        const teamConfig = Math.random() < 0.5 ? 1 : 2;


        if (teamConfig === 1) {

            players = [

                { ...playerSockets[0].user, socketId: playerSockets[0].id, position: 'left', team: 1 },

                { ...playerSockets[1].user, socketId: playerSockets[1].id, position: 'top', team: 1 },

                { ...playerSockets[2].user, socketId: playerSockets[2].id, position: 'right', team: 2 },

                { ...playerSockets[3].user, socketId: playerSockets[3].id, position: 'bottom', team: 2 }

            ];

        } else {

            players = [

                { ...playerSockets[0].user, socketId: playerSockets[0].id, position: 'left', team: 1 },

                { ...playerSockets[1].user, socketId: playerSockets[1].id, position: 'bottom', team: 1 },

                { ...playerSockets[2].user, socketId: playerSockets[2].id, position: 'right', team: 2 },

                { ...playerSockets[3].user, socketId: playerSockets[3].id, position: 'top', team: 2 }

            ];

        }

        players.forEach(p => {

            const center = (gameConfig.canvasSize / 2) - (gameConfig.paddleSize / 2);

            if (p.position === 'left') { p.x = 0; p.y = center; }

            if (p.position === 'right') { p.x = gameConfig.canvasSize - gameConfig.paddleThickness; p.y = center; }

            if (p.position === 'top') { p.y = 0; p.x = center; }

            if (p.position === 'bottom') { p.y = gameConfig.canvasSize - gameConfig.paddleThickness; p.x = center; }

        });

    }


    if (players && playerSockets) {

        const roomName = `game_${Date.now()}`;

        playerSockets.forEach(sock => {

            sock.join(roomName);

            sock.gameRoom = { id: roomName, mode: mode };

        });

        const game = startGameLoop(roomName, players, io, mode, gameConfig);

        state.gameRooms.set(roomName, game);

    }


    socket.on('playerMove', (data) => {

        if (!socket.gameRoom) return;

        const game = state.gameRooms.get(socket.gameRoom.id);

        if (!game) return;

        const playerState = game.gameState.players.find(p => p.id === socket.user.id);

        if (!playerState) return;

        const { newPosition } = data;

        const { canvasSize, paddleSize } = gameConfig;

        let finalPosition = newPosition;

        if (finalPosition < 0) finalPosition = 0;

        if (finalPosition > canvasSize - paddleSize) finalPosition = canvasSize - paddleSize;

        if (playerState.position === 'left' || playerState.position === 'right') playerState.y = finalPosition;

        if (playerState.position === 'top' || playerState.position === 'bottom') playerState.x = finalPosition;

    });

}


module.exports = gameHandler;






backend/websockets/index.js:

// backend/websockets/index.js

const jwt = require('jsonwebtoken');

const prisma = require('../prisma/db');

const chatHandler = require('./chatHandler');

const gameHandler = require('./gameHandler');

const JWT_SECRET = process.env.JWT_SECRET;


// Paylaşılan değişkenler (shared state)

const onlineUsers = new Map();

const gameState = {

    waitingPlayers: {

        '1v1': [],

        '2v2': []

    },

    gameRooms: new Map()

};


function initializeSocket(io) {

    // Kimlik Doğrulama Middleware'i

    io.use(async (socket, next) => {

        const token = socket.handshake.auth.token;

        if (!token) return next(new Error('Authentication error'));

        try {

            const decoded = jwt.verify(token, JWT_SECRET);

            const user = await prisma.user.findUnique({

                where: { id: decoded.userId },

                select: { id: true, email: true, name: true }

            });

            if (!user) return next(new Error('User not found'));

            socket.user = user;

            next();

        } catch (err) {

            return next(new Error('Invalid token'));

        }

    });


    // Ana Bağlantı Olayı

    io.on('connection', (socket) => {

        // --- TEKİL OTURUM KONTROLÜ ---

        // Bu kullanıcıya ait eski bir bağlantı var mı diye kontrol et.

        if (onlineUsers.has(socket.user.id)) {

            const oldSocketId = onlineUsers.get(socket.user.id).socketId;

            const oldSocket = io.sockets.sockets.get(oldSocketId);

            if (oldSocket) {

                // Eski tarayıcıya "oturumu sonlandır" mesajı gönder.

                oldSocket.emit('forceDisconnect', 'Başka bir yerden giriş yapıldı.');

                // Eski bağlantıyı sunucudan kopar.

                oldSocket.disconnect();

                console.log(`Eski oturum sonlandırıldı: ${socket.user.email} (Socket ID: ${oldSocketId})`);

            }

        }

        // --- KONTROL SONU ---


        console.log(`${socket.user.email} bağlandı. (Socket ID: ${socket.id})`);

        onlineUsers.set(socket.user.id, { id: socket.user.id, socketId: socket.id, email: socket.user.email, name: socket.user.name });

        io.emit('update user list', Array.from(onlineUsers.values()));


        socket.on('requestUserList', () => {

            socket.emit('update user list', Array.from(onlineUsers.values()));

        });


        chatHandler(io, socket, onlineUsers);


        socket.on('joinMatchmaking', (payload) => {

            console.log(`${socket.user.email} eşleştirme havuzuna katıldı. Mod: ${payload.mode}`);

            gameHandler(io, socket, gameState, payload);

        });


        // --- GÜVENLİ TEMİZLEME FONKSİYONU ---

        const cleanUpPlayer = async (sock) => {

            // Oyuncuyu tüm bekleme havuzlarından kaldır

            Object.keys(gameState.waitingPlayers).forEach(mode => {

                const pool = gameState.waitingPlayers[mode];

                const newPool = pool.filter(p => p.id !== sock.id);

                if (newPool.length < pool.length) {

                    console.log(`${sock.user.email}, ${mode} bekleme havuzundan kaldırıldı.`);

                    gameState.waitingPlayers[mode] = newPool;

                    newPool.forEach(p => p.emit('updateQueue', { queueSize: newPool.length, requiredSize: mode === '1v1' ? 2 : 4 }));

                }

            });


            // Oyuncu bir oyun odasındaysa, oyunu bitir.

            if (sock.gameRoom) {

                const game = gameState.gameRooms.get(sock.gameRoom.id);

                if (game) {

                    clearInterval(game.intervalId);


                    // Oyundan düşen oyuncunun takımı kaybeder

                    const leavingPlayer = game.players.find(p => p.socketId === sock.id);

                    if (leavingPlayer) {

                        const losingTeam = leavingPlayer.team;

                        const winningTeam = losingTeam === 1 ? 2 : 1;

                        

                        const winners = game.players.filter(p => p.team === winningTeam);

                        const losers = game.players.filter(p => p.team === losingTeam);


                        // İstatistikleri güncelle ve maçı "forfeit" olarak kaydet

                        await updatePlayerStats(winners.map(p => p.id), 'win');

                        await updatePlayerStats(losers.map(p => p.id), 'loss');

                        await saveMatch(game, winningTeam, true); // saveMatch'i birazdan oluşturacağız


                        // Kalan oyunculara haber ver

                        winners.forEach(p => {

                            const otherSocket = io.sockets.sockets.get(p.socketId);

                            if(otherSocket) otherSocket.emit('gameOver', { 

                                winners, 

                                losers, 

                                reason: 'forfeit' // YENİ: Ayrılma nedenini de gönderiyoruz

                            });

                        });

                    }

                    gameState.gameRooms.delete(sock.gameRoom.id);

                    console.log(`Oda ${sock.gameRoom.id} (terk edildi) temizlendi.`);

                }

            }

        };


        socket.on('leaveGameOrLobby', () => {

            console.log(`${socket.user.email} oyun/lobi'den manuel olarak ayrıldı.`);

            cleanUpPlayer(socket);

        });


        // Bağlantı Kesilme Olayı

        socket.on('disconnect', () => {

            console.log(`${socket.user.email} bağlantısı kesildi.`);

            // Sadece bu soket gerçekten listedeki son soket ise onlineUsers'dan sil

            if (onlineUsers.has(socket.user.id) && onlineUsers.get(socket.user.id).socketId === socket.id) {

                onlineUsers.delete(socket.user.id);

                io.emit('update user list', Array.from(onlineUsers.values()));

            }

            cleanUpPlayer(socket);

        });

    });

}


module.exports = initializeSocket;






backend/.env:

DATABASE_URL="file:./prisma/dev.db"

JWT_SECRET="YourSecretKeyGoesHere"






backend/.esnlintrc.json:

{

    "env": {

        "commonjs": true,

        "es2021": true,

        "node": true

    },

    "extends": ["eslint:recommended", "plugin:prettier/recommended"],

    "parserOptions": {

        "ecmaVersion": "latest"

    },

    "rules": {}

}






backend/.gitignore:

node_modules

# Keep environment variables out of version control

.env


/generated/prisma






backend/.prettierrc.json:

{

    "tabWidth": 4,

    "useTabs": false,

    "semi": true,

    "singleQuote": true,

    "trailingComma": "es5",

    "bracketSpacing": true,

    "bracketSameLine": false

}






backend/Dockerfile:

# backend/Dockerfile


# Istenildiği gibi Node.js'in 20 versiyonunu temel alıyoruz.

FROM node:20


# Konteyner içinde çalışacağımız dizini belirliyoruz.

WORKDIR /usr/src/app


# Sadece bağımlılıkları yüklemek için package.json dosyasını kopyala

COPY package*.json ./


# Proje bağımlılıklarını kuruyoruz.

RUN npm install


# --- YENİ VE KRİTİK ADIM ---

# Prisma şemasını kopyala

COPY ./prisma ./prisma/


# "Terziyi çağır": Prisma Client'ı şemaya göre oluştur.

RUN npx prisma generate

# -----------------------------


# Proje kaynak kodunun geri kalanını konteynere kopyalıyoruz.

COPY . .


# Uygulamayı başlatacak olan komutu belirtiyoruz.

CMD ["npm", "run", "dev"]






backend/package.json:

{

  "name": "backend",

  "version": "1.0.0",

  "description": "",

  "main": "server.js",

  "scripts": {

    "start": "node server.js",

    "dev": "nodemon server.js",

    "lint": "eslint .",

    "format": "prettier --write .",

    "test": "echo \"Error: no test specified\" && exit 1"

  },

  "keywords": [],

  "author": "",

  "license": "ISC",

  "dependencies": {

    "@fastify/cors": "^11.1.0",

    "@prisma/client": "^6.15.0",

    "bcrypt": "^6.0.0",

    "dotenv": "^17.2.2",

    "fastify": "^5.6.0",

    "jsonwebtoken": "^9.0.2",

    "socket.io": "^4.8.1"

  },

  "devDependencies": {

    "eslint": "^9.35.0",

    "eslint-config-prettier": "^10.1.8",

    "eslint-plugin-prettier": "^5.5.4",

    "nodemon": "^3.1.10",

    "prettier": "^3.6.2",

    "prisma": "^6.15.0"

  }

}






backend/server.js:

// backend/server.js

require('dotenv').config();


const fastify = require('fastify')({ logger: true });

const { Server } = require('socket.io');

const cors = require('@fastify/cors');

const initializeSocket = require('./websockets');


// Eklentileri Kaydet

fastify.register(cors, { origin: "*" });


// HTTP Yollarını Kaydet

fastify.register(require('./api/auth.routes'));

fastify.register(require('./api/users.routes'));


// Socket.io Sunucusunu Başlat

const io = new Server(fastify.server, {

    cors: { origin: "*", methods: ["GET", "POST"] }

});

initializeSocket(io);


// Ana Durum Yolu

fastify.get('/', (request, reply) => {

    reply.send({ status: 'Server is running - Refactored!' });

});


// Sunucuyu Başlatma Fonksiyonu

const start = async () => {

    try {

        await fastify.listen({ port: 3000, host: '0.0.0.0' });

    } catch (err) {

        fastify.log.error(err);

        process.exit(1);

    }

};


start();






frontend/src/api/auth.ts:

// frontend/src/api/auth.ts


// Ortam değişkeninden API adresini alıyoruz

const API_URL = `http://${window.location.hostname}:3000`;


// DÜZELTME: Parametrelere ': string' tipi eklendi

export async function loginUser(email: string, password: string) {

  const response = await fetch(`${API_URL}/login`, {

    method: 'POST',

    headers: { 'Content-Type': 'application/json' },

    body: JSON.stringify({ email, password }),

  });


  if (!response.ok) {

    const errorData = await response.json();

    throw new Error(errorData.error || 'Giriş başarısız oldu.');

  }


  return response.json();

}


// DÜZELTME: Parametrelere ': string' tipi eklendi

export async function registerUser(email: string, password: string, name: string) {

  const response = await fetch(`${API_URL}/register`, {

    method: 'POST',

    headers: { 'Content-Type': 'application/json' },

    body: JSON.stringify({ email, password, name }),

  });


  if (!response.ok) {

    const errorData = await response.json();

    throw new Error(errorData.error || 'Kayıt başarısız oldu.');

  }


  return response.json();

}






frontend/src/api/users.ts:

const API_URL = `http://${window.location.hostname}:3000`;


export async function getUserProfile(userId: string) {

  const token = localStorage.getItem('token');

  if (!token) {

    throw new Error('Not authenticated');

  }


  const response = await fetch(`${API_URL}/users/${userId}`, {

    method: 'GET',

    headers: {

      'Authorization': `Bearer ${token}`,

    },

  });


  if (!response.ok) {

    const errorData = await response.json();

    throw new Error(errorData.error || 'Failed to fetch user profile.');

  }


  return response.json();

}


export async function getMatchHistory(userId: string) {

  const token = localStorage.getItem('token');

  if (!token) {

    throw new Error('Not authenticated');

  }


  const response = await fetch(`${API_URL}/users/${userId}/matches`, {

    method: 'GET',

    headers: {

      'Authorization': `Bearer ${token}`,

    },

  });


  if (!response.ok) {

    const errorData = await response.json();

    throw new Error(errorData.error || 'Failed to fetch match history.');

  }


  return response.json();

}






frontend/src/pages/DashboardPage.ts:

// frontend/src/pages/DashboardPage.ts

import { navigateTo } from '../router';

import { getSocket, disconnectSocket } from '../socket';

import { t } from '../i18n';

import { jwt_decode } from '../utils';

import type { Socket } from "socket.io-client";

import { addMessage, getMessages, clearMessages } from '../chatState';


// Sayfa bazında değişkenleri tanımla

let socket: Socket | null = null;

let myId: number | null = null;


export function render(): string {

  // Navigasyon çubuğunu sol, orta ve sağ olmak üzere üç ana bölüme ayırıyoruz.

  return `

    <div class="h-screen w-screen flex flex-col bg-gray-100">

      <nav class="bg-gray-800 text-white p-4 flex justify-between items-center w-full">

        

        <div class="w-1/3">

          </div>


        <div class="w-1/3 text-center">

          <h1 class="text-xl font-bold">Transcendence</h1>

        </div>


        <div class="w-1/3 flex justify-end items-center space-x-4">

          <a href="/lobby" data-link class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">${t('go_to_game')}</a>

          <button id="logout-button" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">${t('logout')}</button>

        </div>


      </nav>


      <div class="flex flex-grow overflow-hidden p-4 space-x-4">

        

        <div class="w-1/4 bg-white p-4 rounded-lg shadow-md overflow-y-auto">

          <h2 class="text-lg font-bold mb-4">${t('online_users')}</h2>

          <ul id="user-list" class="space-y-2"></ul>

        </div>


        <div class="w-3/4 flex flex-col bg-white rounded-lg shadow-md">

          <div class="p-4 border-b">

            <strong>${t('recipient')}:</strong> <span id="recipient-info">${t('everyone')}</span>

          </div>

          <ul id="messages" class="flex-grow p-4 overflow-y-auto"></ul>

          <form id="chat-form" class="p-4 bg-gray-200 flex rounded-b-lg">

            <input id="chat-input" autocomplete="off" placeholder="${t('chat_placeholder')}" class="border rounded-l-md p-2 flex-grow" />

            <button type="submit" class="bg-blue-500 text-white px-4 rounded-r-md hover:bg-blue-600">${t('send_button')}</button>

          </form>

        </div>


      </div>

    </div>

  `;

}


export function afterRender() {

  const logoutButton = document.getElementById('logout-button');

  logoutButton?.addEventListener('click', () => {

      clearMessages();

      localStorage.removeItem('token');

      disconnectSocket();

      navigateTo('/');

  });


  socket = getSocket()!;

  socket.emit('requestUserList');


  const token = localStorage.getItem('token');

  if (token) {

      myId = jwt_decode(token).userId;

  }


  const userList = document.getElementById('user-list') as HTMLUListElement;

  const recipientInfo = document.getElementById('recipient-info') as HTMLSpanElement;

  const messagesList = document.getElementById('messages') as HTMLUListElement;

  const chatForm = document.getElementById('chat-form') as HTMLFormElement;

  const chatInput = document.getElementById('chat-input') as HTMLInputElement;


  // Sayfa yüklendiğinde hafızadaki mesajları (sessionStorage) ekrana yazdır

  messagesList.innerHTML = '';

  const existingMessages = getMessages();

  existingMessages.forEach(msg => {

    const item = document.createElement('li');

    // Mesaj objesini o anki dile göre metne çeviriyoruz

    const prefix = t(msg.type === 'public' ? 'chat_public_prefix' : 'chat_private_prefix');

    item.textContent = `${prefix} ${msg.sender}: ${msg.content}`;

    messagesList.appendChild(item);

  });

  if (messagesList.children.length > 0) {

      messagesList.scrollTop = messagesList.scrollHeight;

  }


  let selectedRecipient: any = null;


  function selectRecipient(user: any) {

    selectedRecipient = user;

    recipientInfo.textContent = user.name || user.email || t('everyone');

    document.querySelectorAll('#user-list li').forEach(li => {

        li.classList.toggle('bg-blue-200', (li as HTMLElement).dataset.id == (user.id || 'all'));

    });

  }


  socket.on('update user list', (users: any[]) => {

    const currentSelectedId = selectedRecipient ? selectedRecipient.id : 'all';

    userList.innerHTML = ''; // Önce mevcut listeyi tamamen temizle

    

    // 1. ADIM: "Herkese" seçeneğini her zaman en üste ekle

    const allOption = document.createElement('li');

    allOption.textContent = t('everyone');

    allOption.dataset.id = 'all';

    allOption.classList.add('p-2', 'hover:bg-gray-200', 'cursor-pointer', 'rounded');

    allOption.addEventListener('click', () => selectRecipient({ id: 'all', name: t('everyone') }));

    userList.appendChild(allOption);


    // 2. ADIM: Mevcut kullanıcıyı (SEN) bul ve ikinci sıraya ekle

    const me = users.find(user => user.id === myId);

    if (me) {

        const myItem = document.createElement('li');

        myItem.dataset.id = me.id.toString();

        myItem.classList.add('p-2', 'hover:bg-gray-200', 'cursor-pointer', 'rounded');


        const myLink = document.createElement('a');

        myLink.href = `/profile/${me.id}`;

        myLink.setAttribute('data-link', '');

        myLink.textContent = `${me.name || me.email} ${t('you_suffix')}`;

        myItem.appendChild(myLink);

        

        myItem.addEventListener('click', (e) => {

            if ((e.target as HTMLElement).tagName === 'A') return;

            // Kendine özel mesaj atma hala engelli

        });

        userList.appendChild(myItem);

    }


    // 3. ADIM: Diğer tüm kullanıcıları listele

    users.forEach(user => {

        // Eğer kullanıcı "sen" değilsen, listeye ekle

        if (user.id !== myId) {

            const item = document.createElement('li');

            item.dataset.id = user.id.toString();

            item.classList.add('p-2', 'hover:bg-gray-200', 'cursor-pointer', 'rounded');


            const userLink = document.createElement('a');

            userLink.href = `/profile/${user.id}`;

            userLink.setAttribute('data-link', '');

            userLink.textContent = user.name || user.email;

            item.appendChild(userLink);

            

            item.addEventListener('click', (e) => {

                if ((e.target as HTMLElement).tagName === 'A') return;

                selectRecipient(user);

            });


            userList.appendChild(item);

        }

    });


    // Sayfa yenilendiğinde seçili kullanıcıyı koru veya varsayılana dön

    const newSelectedUser = users.find(u => u.id === currentSelectedId);

    selectRecipient(newSelectedUser || { id: 'all', name: t('everyone') });

  });


  socket.on('chat message', (msg: any) => {

    // Gelen mesaj objesini doğrudan hafızaya (sessionStorage) ekle

    addMessage(msg);


    const prefix = t(msg.type === 'public' ? 'chat_public_prefix' : 'chat_private_prefix');

    const fullMessage = `${prefix} ${msg.sender}: ${msg.content}`;


    const item = document.createElement('li');

    item.textContent = fullMessage;

    messagesList.appendChild(item);

    messagesList.scrollTop = messagesList.scrollHeight;

  });


  chatForm.addEventListener('submit', (e) => {

    e.preventDefault();

    if (chatInput.value && socket) {

      if (selectedRecipient && selectedRecipient.id !== 'all') {

        socket.emit('private message', {

          recipientId: selectedRecipient.id,

          message: chatInput.value

        });

      } else {

        socket.emit('chat message', chatInput.value);

      }

      chatInput.value = '';

    }

  });

}


export function cleanup() {

  console.log('Dashboard sayfasından ayrılıyor, sohbet geçmişi ve dinleyiciler temizleniyor...');

  

  // Önceki isteğin üzerine sohbet geçmişini temizliyoruz.

  clearMessages();


  // *** SORUNU ÇÖZEN KISIM BAŞLANGICI ***

  // Bu sayfadan ayrılırken, bu sayfada eklediğimiz dinleyicileri kaldırıyoruz.

  // Bu, mesajların katlanarak çoğalmasını engeller.

  const socket = getSocket();

  if (socket) {

    socket.off('update user list');

    socket.off('chat message');

  }

}






frontend/src/pages/LobbyPage.ts:

import { navigateTo } from "../router";

import { t } from '../i18n';


export function render() {

  return `

    <div class="min-h-screen bg-gray-100 flex flex-col items-center justify-center">

      <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md text-center">

        <h2 class="text-2xl font-bold mb-6">${t('lobby_title')}</h2>

        <div class="flex flex-col space-y-4">

          <a href="/local-game" data-link class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded">

            ${t('play_local_button')}

          </a>

          <a href="/online-lobby" data-link class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-4 rounded">

            ${t('play_online_button')}

          </a>

        </div>

        <a href="/dashboard" data-link class="mt-8 inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800">

          ${t('return_to_chat')}

        </a>

      </div>

    </div>

  `;

}


export function afterRender() {

    // DEĞİŞİKLİK: Artık butonu doğru href üzerinden arıyoruz.

    const onlineButton = document.querySelector('a[href="/online-lobby"]');

    

    onlineButton?.addEventListener('click', (e) => {

        e.preventDefault();

        navigateTo('/online-lobby');

    });

}






frontend/src/pages/LocalGamePage.ts:

// frontend/src/pages/GamePage.ts

// Oyun ayarları


import { t } from '../i18n';

const PADDLE_WIDTH = 10;

const PADDLE_HEIGHT = 100;

const BALL_SIZE = 10;


// Oyun durumu (state)

let gameState = {

  leftPaddleY: 250,

  rightPaddleY: 250,

  ballX: 400,

  ballY: 300,

  ballSpeedX: 5,

  ballSpeedY: 5,

  leftScore: 0,

  rightScore: 0,

};


let canvas: HTMLCanvasElement;

let context: CanvasRenderingContext2D;

let animationFrameId: number;

const keysPressed: { [key: string]: boolean } = {};


export function render() {

  return `

    <div class="h-screen w-screen bg-gray-900 flex flex-col items-center justify-center">

      <h1 class="text-3xl text-white mb-4">Pong Game</h1>

      <canvas id="pong-canvas" width="800" height="600" class="bg-black border border-white"></canvas>

      <a href="/dashboard" data-link class="mt-4 text-blue-400 hover:text-blue-300">

        ${t('return_to_chat')}

      </a>

    </div>

  `;

}


// Çizim fonksiyonları

function drawRect(x: number, y: number, w: number, h: number, color: string) {

  context.fillStyle = color;

  context.fillRect(x, y, w, h);

}


function drawCircle(x: number, y: number, r: number, color: string) {

  context.fillStyle = color;

  context.beginPath();

  context.arc(x, y, r, 0, Math.PI * 2, false);

  context.fill();

}


function drawText(text: string, x: number, y: number, color: string) {

  context.fillStyle = color;

  context.font = "75px fantasy";

  context.fillText(text, x, y);

}


function renderGame() {

  if (!context) return;

  drawRect(0, 0, canvas.width, canvas.height, "black");

  drawText(gameState.leftScore.toString(), canvas.width / 4, canvas.height / 5, "white");

  drawText(gameState.rightScore.toString(), 3 * canvas.width / 4, canvas.height / 5, "white");

  drawRect(0, gameState.leftPaddleY, PADDLE_WIDTH, PADDLE_HEIGHT, "white");

  drawRect(canvas.width - PADDLE_WIDTH, gameState.rightPaddleY, PADDLE_WIDTH, PADDLE_HEIGHT, "white");

  drawCircle(gameState.ballX, gameState.ballY, BALL_SIZE, "white");

}


function resetBall() {

  gameState.ballX = canvas.width / 2;

  gameState.ballY = canvas.height / 2;

  gameState.ballSpeedX = -gameState.ballSpeedX;

  gameState.ballSpeedY = 5;

}


function update() {

  if (!canvas) return;

  // Paddle movements

  if (keysPressed['w'] && gameState.leftPaddleY > 0) {

    gameState.leftPaddleY -= 8;

  }

  if (keysPressed['s'] && gameState.leftPaddleY < canvas.height - PADDLE_HEIGHT) {

    gameState.leftPaddleY += 8;

  }

  if (keysPressed['ArrowUp'] && gameState.rightPaddleY > 0) {

    gameState.rightPaddleY -= 8;

  }

  if (keysPressed['ArrowDown'] && gameState.rightPaddleY < canvas.height - PADDLE_HEIGHT) {

    gameState.rightPaddleY += 8;

  }


  // Ball movement

  gameState.ballX += gameState.ballSpeedX;

  gameState.ballY += gameState.ballSpeedY;


  // Ball collision with top/bottom walls

  if (gameState.ballY - BALL_SIZE < 0 || gameState.ballY + BALL_SIZE > canvas.height) {

    gameState.ballSpeedY = -gameState.ballSpeedY;

  }


  // Ball collision with paddles

  if (

    gameState.ballX - BALL_SIZE < PADDLE_WIDTH &&

    gameState.ballY > gameState.leftPaddleY &&

    gameState.ballY < gameState.leftPaddleY + PADDLE_HEIGHT

  ) {

    gameState.ballSpeedX = -gameState.ballSpeedX;

  }

  if (

    gameState.ballX + BALL_SIZE > canvas.width - PADDLE_WIDTH &&

    gameState.ballY > gameState.rightPaddleY &&

    gameState.ballY < gameState.rightPaddleY + PADDLE_HEIGHT

  ) {

    gameState.ballSpeedX = -gameState.ballSpeedX;

  }


  // Score and reset

  if (gameState.ballX - BALL_SIZE < 0) {

    gameState.rightScore++;

    resetBall();

  } else if (gameState.ballX + BALL_SIZE > canvas.width) {

    gameState.leftScore++;

    resetBall();

  }

}


function gameLoop() {

  update();

  renderGame();

  animationFrameId = requestAnimationFrame(gameLoop); // ID'yi sakla

}


export function afterRender() {

  const localCanvas = document.getElementById('pong-canvas') as HTMLCanvasElement;

  if (localCanvas) {

    canvas = localCanvas;

    context = canvas.getContext('2d')!;


    // Dinleyicileri yeni fonksiyonlarla ekle

    window.addEventListener('keydown', handleKeyDown);

    window.addEventListener('keyup', handleKeyUp);


    gameLoop();

  }

}


export function cleanup() {

  cancelAnimationFrame(animationFrameId); // Oyun döngüsünü durdur

  // Eklediğimiz klavye dinleyicilerini kaldır

  window.removeEventListener('keydown', handleKeyDown);

  window.removeEventListener('keyup', handleKeyUp);

  // Oyun durumunu sıfırla

  gameState = {

    leftPaddleY: 250,

    rightPaddleY: 250,

    ballX: 400,

    ballY: 300,

    ballSpeedX: 5,

    ballSpeedY: 5,

    leftScore: 0,

    rightScore: 0,

  };

}


function handleKeyDown(event: KeyboardEvent) {

  keysPressed[event.key] = true;

}

function handleKeyUp(event: KeyboardEvent) {

  keysPressed[event.key] = false;

}






frontend/src/pages/LoginPage.ts:

// frontend/src/pages/LoginPage.ts

import { t } from '../i18n';

import { loginUser } from '../api/auth';

import { navigateTo } from '../router';



export function render() {

  return `

    <div class="min-h-screen bg-gray-100 flex items-center justify-center">

      <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md">

        <h2 class="text-2xl font-bold mb-6 text-center">${t('login_title')}</h2>

        <form id="login-form">

          <div class="mb-4">

            <label for="email" class="block text-gray-700 text-sm font-bold mb-2">${t('email_label')}</label>

            <input type="email" id="email" name="email" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" required>

          </div>

          <div class="mb-6">

            <label for="password" class="block text-gray-700 text-sm font-bold mb-2">${t('password_label')}</label>

            <input type="password" id="password" name="password" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline" required>

          </div>

          <div class="flex items-center justify-between">

            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">

              ${t('login_button')}

            </button>

            <a href="/register" class="inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800" data-link>

              ${t('register_link')}

            </a>

          </div>

        </form>

      </div>

    </div>

  `;

}


export function afterRender() {

  const form = document.querySelector<HTMLFormElement>('#login-form');

  if (form) {

    form.addEventListener('submit', async (e) => {

      e.preventDefault();

      const email = (form.querySelector('#email') as HTMLInputElement).value;

      const password = (form.querySelector('#password') as HTMLInputElement).value;


      try {

        const data = await loginUser(email, password);

        localStorage.setItem('token', data.token);

        navigateTo('/dashboard');

      }

      catch (error: any)

      {

        // Backend'den gelen mesaja göre çeviri yap

        const errorMessage = error.message;

        if (errorMessage.includes('Invalid credentials'))

          alert(t('error_invalid_credentials'));

        else

          // Bilinmeyen diğer hatalar için genel mesaj

          alert(errorMessage);

      }

    });

  }

}






frontend/src/pages/MatchHistoryPage.ts:

import { t } from '../i18n';

import { getMatchHistory } from '../api/users';

import { getUserProfile } from '../api/users'; // Kullanıcı adını almak için bunu da import ediyoruz


// Yardımcı fonksiyon: Saniyeyi "dakika:saniye" formatına çevirir

function formatDuration(seconds: number): string {

    const minutes = Math.floor(seconds / 60);

    const remainingSeconds = seconds % 60;

    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;

}


export function render(): string {

  return `

    <div class="min-h-screen bg-gray-100 p-4 sm:p-8">

      <h1 id="history-title" class="text-3xl font-bold mb-6 text-center text-gray-800">${t('match_history_title')}</h1>

      <div id="match-history-list" class="space-y-4 max-w-4xl mx-auto">

        <p class="text-center text-gray-500">${t('loading_history')}</p>

      </div>

       <div class="text-center mt-8">

         <a id="back-to-profile-link" href="#" data-link class="text-blue-500 hover:text-blue-800">${t('back_button')}</a>

      </div>

    </div>

  `;

}


export async function afterRender() {

    const listContainer = document.getElementById('match-history-list');

    const titleElement = document.getElementById('history-title');

    const backLink = document.getElementById('back-to-profile-link');


    const pathParts = window.location.pathname.split('/');

    const userId = pathParts[2];


    if (!listContainer || !userId || !titleElement || !backLink) return;

    

    backLink.setAttribute('href', `/profile/${userId}`);


    try {

        const userProfile = await getUserProfile(userId);

        if (titleElement) {

            const userName = userProfile.name || 'User';

            titleElement.textContent = t('match_history_for_user').replace('{name}', userName);

        }

        const matches = await getMatchHistory(userId);

        listContainer.innerHTML = '';


        if (matches.length === 0) {

            listContainer.innerHTML = `<p class="text-center text-gray-500">${t('no_matches_found')}</p>`;

            return;

        }


        const profileOwnerId = parseInt(userId, 10);


        matches.forEach((match: any) => {

            const isPlayer1 = match.player1Id === profileOwnerId;

            const myData = isPlayer1 ? match.player1 : match.player2;

            const opponentData = isPlayer1 ? match.player2 : match.player1;

            

            const myStats = isPlayer1 

                ? { score: match.player1Score, hits: match.player1Hits, misses: match.player1Misses }

                : { score: match.player2Score, hits: match.player2Hits, misses: match.player2Misses };

            const opponentStats = isPlayer1

                ? { score: match.player2Score, hits: match.player2Hits, misses: match.player2Misses }

                : { score: match.player1Score, hits: match.player1Hits, misses: match.player1Misses };


            const iWon = match.winnerId === profileOwnerId;


            const myTotalShots = myStats.hits + myStats.misses;

            const myAccuracy = myTotalShots > 0 ? ((myStats.hits / myTotalShots) * 100).toFixed(0) : 0;

            

            const opponentTotalShots = opponentStats.hits + opponentStats.misses;

            const opponentAccuracy = opponentTotalShots > 0 ? ((opponentStats.hits / opponentTotalShots) * 100).toFixed(0) : 0;


            const matchElement = document.createElement('div');

            matchElement.className = `bg-white p-4 rounded-lg shadow-md flex items-center justify-between border-l-8 ${iWon ? 'border-green-500' : 'border-red-500'}`;

            

            matchElement.innerHTML = `

                <div class="flex-1 text-center">

                    <p class="font-bold text-lg">${myData.name} ${iWon ? `(${t('you_suffix')})` : ''}</p>

                    <p class="text-sm ${iWon ? 'text-green-600' : 'text-red-600'} font-bold">${iWon ? t('outcome_win') : t('outcome_lose')}</p>

                    <div class="mt-2 text-xs text-gray-500">

                        <p>${t('stat_accuracy')}: ${myAccuracy}%</p>

                        <p>${t('stat_missed')}: ${myStats.misses}</p>

                    </div>

                </div>


                <div class="text-center border-l border-r px-4 mx-4">

                    <p class="text-4xl font-bold">

                        <span>${myStats.score}</span> - <span>${opponentStats.score}</span>

                    </p>

                    <p class="text-xs text-gray-400 mt-2">${new Date(match.createdAt).toLocaleString()}</p>

                    <p class="text-xs text-gray-400">${t('stat_duration')}: ${formatDuration(match.durationInSeconds)}</p>

                </div>


                <div class="flex-1 text-center">

                    <p class="font-bold text-lg">${opponentData.name}</p>

                    <p class="text-sm ${!iWon ? 'text-green-600' : 'text-red-600'} font-bold">${!iWon ? t('outcome_win') : t('outcome_lose')}</p>

                     <div class="mt-2 text-xs text-gray-500">

                        <p>${t('stat_accuracy')}: ${opponentAccuracy}%</p>

                        <p>${t('stat_missed')}: ${opponentStats.misses}</p>

                    </div>

                </div>

            `;

            listContainer.appendChild(matchElement);

        });


    } catch (error) {

        console.error(error);

        listContainer.innerHTML = `<p class="text-center text-red-500">${t('history_load_error')}</p>`;

    }

}






frontend/src/pages/OnlineGamePage.ts:

// frontend/src/pages/OnlineGamePage.ts

import { getSocket } from '../socket';

import type { Socket } from 'socket.io-client';

import { jwt_decode } from '../utils';

import { t } from '../i18n';


// Sayfa bazında kullanılacak değişkenler

let socket: Socket | null = null;

let canvas: HTMLCanvasElement;

let context: CanvasRenderingContext2D;

let gameState: any = {};

let gameConfig: any = {}; // Oyun ayarlarını (canvas boyutu, raket boyutu vb.) tutacak

let myPlayer: any = null; // Oyuncunun kendi bilgilerini (pozisyonu, takımı vb.) tutacak

let animationFrameId: number;


// OYUNU ÇİZME FONKSİYONU

function renderGame() {

    if (!context || !gameState.players || !gameConfig.canvasSize) return;


    const { players, ballX, ballY, team1Score, team2Score } = gameState;

    const { canvasSize, paddleSize, paddleThickness } = gameConfig;


    // 1. Arka planı temizle

    context.fillStyle = 'black';

    context.fillRect(0, 0, canvasSize, canvasSize);


    // 2. Skorları çiz

    context.fillStyle = 'white';

    context.font = "75px fantasy";

    context.textAlign = 'center';

    context.fillText(team1Score.toString(), canvasSize / 4, canvasSize / 5);

    context.fillText(team2Score.toString(), (canvasSize * 3) / 4, canvasSize / 5);


    // 3. Dört raketi de pozisyonlarına ve takımlarına göre çiz

    players.forEach((player: any) => {

        context.fillStyle = player.team === 1 ? '#60a5fa' : '#f87171'; // Takım 1 Mavi, Takım 2 Kırmızı

        

        if (player.position === 'left' || player.position === 'right') {

            context.fillRect(player.x, player.y, paddleThickness, paddleSize);

        } else { // 'top' veya 'bottom'

            context.fillRect(player.x, player.y, paddleSize, paddleThickness);

        }

    });


    // 4. Topu çiz

    context.fillStyle = 'white';

    context.beginPath();

    context.arc(ballX, ballY, 10, 0, Math.PI * 2);

    context.fill();

}


// OYUN DÖNGÜSÜ

function gameLoop() {

    renderGame();

    animationFrameId = requestAnimationFrame(gameLoop);

}


// KONTROL MANTIĞI

function handlePlayerMove(event: KeyboardEvent) {

    if (!socket || !myPlayer || !gameState.players) return;


    // Oyuncunun güncel pozisyonunu gameState'den bul

    const playerState = gameState.players.find((p: any) => p.id === myPlayer.id);

    if (!playerState) return;


    let currentPos: number;

    // Oyuncunun pozisyonuna göre hangi eksende hareket ettiğini belirle

    if (myPlayer.position === 'left' || myPlayer.position === 'right') {

        currentPos = playerState.y; // Dikey hareket

    } else {

        currentPos = playerState.x; // Yatay hareket

    }


    let newPos: number | undefined;

    // W/Yukarı Ok -> Yukarı veya Sola hareket

    if (event.key === 'w' || event.key === 'ArrowUp') {

        newPos = currentPos - 25; // Hareketi biraz hızlandıralım

    } 

    // S/Aşağı Ok -> Aşağı veya Sağa hareket

    else if (event.key === 's' || event.key === 'ArrowDown') {

        newPos = currentPos + 25;

    }


    if (newPos !== undefined) {

        // Yeni pozisyonu sunucuya gönder

        socket.emit('playerMove', { newPosition: newPos });

    }

}


// SAYFANIN HTML'İNİ OLUŞTURMA


export function render(): string {

    return `

    <div class="h-screen w-screen bg-gray-900 flex flex-col items-center justify-center relative">

      <div id="game-status" class="text-3xl text-white mb-4">${t('waiting_for_opponent')}</div>

      <canvas id="pong-canvas" width="800" height="800" class="bg-black border border-white"></canvas>

      <a href="/lobby" data-link class="mt-4 text-blue-400 hover:text-blue-300">${t('leave_lobby')}</a>


      <div id="game-over-modal" class="hidden absolute inset-0 bg-black bg-opacity-75 items-center justify-center text-white">

        <h2 id="game-over-text" class="text-6xl font-bold mb-8"></h2>

        <div id="rematch-prompt" class="hidden items-center">

            <p class="text-xl mb-4">${t('rematch_question')}</p>

            <div class="flex space-x-4">

                <button id="stay-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded">${t('stay_on_page')}</button>

                <a href="/lobby" data-link class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded">${t('return_to_lobby')}</a>

            </div>

        </div>

      </div>

    </div>

  `;

}



// SAYFA YÜKLENDİKTEN SONRA ÇALIŞAN KODLAR

export function afterRender() {

    socket = getSocket()!;


    const statusDiv = document.getElementById('game-status')!;

    const canvasEl = document.getElementById('pong-canvas') as HTMLCanvasElement;

    canvas = canvasEl;

    context = canvas.getContext('2d')!;

    const gameOverModal = document.getElementById('game-over-modal')!;

    const gameOverText = document.getElementById('game-over-text')!;

    const rematchPrompt = document.getElementById('rematch-prompt')!;

    const stayButton = document.getElementById('stay-button')!;

    

    const token = localStorage.getItem('token');

    const myUserId = token ? jwt_decode(token).userId : null;


    stayButton.addEventListener('click', () => {

        gameOverModal.classList.add('hidden');

    });


    // Sunucudan gelen "bekleme odası güncellendi" mesajını dinle

    socket.on('updateQueue', ({ queueSize, requiredSize }) => {

        statusDiv.textContent = `${t('waiting_for_opponent')} (${queueSize}/${requiredSize})`;

    });


    // Sunucudan gelen "oyun başladı" mesajını dinle

    socket.on('gameStart', (payload) => {

        console.log("Oyun başlıyor:", payload);

        // Sunucudan gelen oyun ayarlarını kaydet

        gameConfig = {

            canvasSize: payload.canvasSize,

            paddleSize: payload.paddleSize,

            paddleThickness: payload.paddleThickness,

            mode: payload.mode

        };

        

        // Canvas boyutlarını ayarla

        canvas.width = gameConfig.canvasSize;

        canvas.height = gameConfig.canvasSize;

        

        statusDiv.textContent = ''; // "Bekleniyor..." yazısını sil

        canvas.classList.remove('hidden'); // Canvas'ı görünür yap

        

        // Oyuncunun kendi bilgilerini bul ve kaydet

        myPlayer = payload.players.find((p: any) => p.id === myUserId);


        // Klavye dinleyicisini başlat

        window.addEventListener('keydown', handlePlayerMove);

        // Oyun döngüsünü başlat

        if (animationFrameId) cancelAnimationFrame(animationFrameId); // Önceki döngüyü temizle

        gameLoop();

    });


    socket.on('gameStateUpdate', (newGameState) => {

        gameState = newGameState;

    });


    socket.on('gameOver', ({ winners }) => {

        window.removeEventListener('keydown', handlePlayerMove);

        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        

        const isWinner = winners.some((winner: any) => winner.id === myUserId);

        

        gameOverText.textContent = isWinner ? t('you_win') : t('you_lose');

        

        // Görünür yaparken flex class'larını ekliyoruz

        gameOverModal.classList.remove('hidden');

        gameOverModal.classList.add('flex', 'flex-col');


        setTimeout(() => {

            // Görünür yaparken flex class'larını ekliyoruz

            rematchPrompt.classList.remove('hidden');

            rematchPrompt.classList.add('flex', 'flex-col');

        }, 3000);

    });

}


// SAYFADAN AYRILIRKEN ÇALIŞAN TEMİZLİK KODLARI

export function cleanup() {

    if (socket) {

      socket.emit('leaveGameOrLobby');

      // Bu sayfaya özel dinleyicileri kaldır

      socket.off('updateQueue');

      socket.off('gameStart');

      socket.off('gameStateUpdate');

      socket.off('opponentLeft');

    }

    // Genel klavye dinleyicisini kaldır

    window.removeEventListener('keydown', handlePlayerMove);

    // Oyun döngüsünü durdur

    if (animationFrameId) {

        cancelAnimationFrame(animationFrameId);

    }

    // Değişkenleri sıfırla

    animationFrameId = 0;

    myPlayer = null;

    gameConfig = {};

    gameState = {};

}






frontend/src/pages/OnlineLobbyPage.ts:

// frontend/src/pages/OnlineLobbyPage.ts

import { navigateTo } from '../router';

import { getSocket } from '../socket';

import { t } from '../i18n';


export function render(): string {

  return `

    <div class="min-h-screen bg-gray-100 flex flex-col items-center justify-center">

      <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md text-center">

        <h2 class="text-2xl font-bold mb-6">${t('online_lobby_title')}</h2>

        <div class="flex flex-col space-y-4">

          <button id="1v1-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded">

            ${t('play_1v1_button')}

          </button>

          <button id="2v2-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-4 rounded">

            ${t('play_2v2_button')}

          </button>

        </div>

        <a href="/lobby" data-link class="mt-8 inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800">

          ${t('back_button')}

        </a>

      </div>

    </div>

  `;

}


// afterRender fonksiyonu aynı kalıyor

export function afterRender() {

  const socket = getSocket();


  document.getElementById('1v1-button')?.addEventListener('click', () => {

    if (socket) {

      socket.emit('joinMatchmaking', { mode: '1v1' });

    }

    navigateTo('/online-game');

  });


  document.getElementById('2v2-button')?.addEventListener('click', () => {

    if (socket) {

      socket.emit('joinMatchmaking', { mode: '2v2' });

    }

    navigateTo('/online-game');

  });

}






frontend/src/pages/ProfilePage.ts:

// frontend/src/pages/ProfilePage.ts

import { t } from '../i18n';

import { getUserProfile } from '../api/users';


export function render(): string {

  return `

    <div class="min-h-screen bg-gray-100 flex flex-col items-center justify-center">

      <div id="profile-card" class="bg-white p-8 rounded-lg shadow-md w-full max-w-md text-center">

        

        <h2 id="profile-name" class="text-3xl font-bold mb-2">Loading...</h2>

        <p id="profile-created-at" class="text-gray-500 text-sm mb-6"></p>

        

        <div class="flex justify-center space-x-8 border-t border-b py-4">

          <div>

            <p class="text-2xl font-bold text-green-500" id="profile-wins">-</p>

            <p class="text-sm text-gray-600">${t('profile_wins')}</p>

          </div>

          <div>

            <p class="text-2xl font-bold text-red-500" id="profile-losses">-</p>

            <p class="text-sm text-gray-600">${t('profile_losses')}</p>

          </div>

        </div>


        <a id="match-history-link" href="#" data-link class="mt-6 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded block">

          ${t('view_match_history')}

        </a>


        <a href="/dashboard" data-link class="mt-4 inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800">

          ${t('return_to_chat')}

        </a>

      </div>

    </div>

  `;

}


export async function afterRender() {

  const nameElement = document.getElementById('profile-name');

  const createdAtElement = document.getElementById('profile-created-at');

  const winsElement = document.getElementById('profile-wins');

  const lossesElement = document.getElementById('profile-losses');

  const matchHistoryLink = document.getElementById('match-history-link'); // Yeni butonu seç


  const pathParts = window.location.pathname.split('/');

  const userId = pathParts[2];


  if (!userId) {

    if (nameElement) nameElement.textContent = 'Invalid Profile';

    return;

  }

  

  // Yeni butonun linkini, görüntülenen kullanıcının ID'sine göre dinamik olarak ayarla

  if (matchHistoryLink) {

    matchHistoryLink.setAttribute('href', `/profile/${userId}/history`);

  }


  try {

    const userProfile = await getUserProfile(userId);

    

    if (nameElement) nameElement.textContent = userProfile.name || 'Unnamed User';

    if (createdAtElement) {

      const joinDate = new Date(userProfile.createdAt).toLocaleDateString();

      createdAtElement.textContent = `${t('profile_joined_on')} ${joinDate}`;

    }

    if (winsElement) winsElement.textContent = userProfile.wins.toString();

    if (lossesElement) lossesElement.textContent = userProfile.losses.toString();


  } catch (error) {

    if (nameElement) nameElement.textContent = 'Profile Not Found';

    console.error(error);

  }

}






frontend/src/pages/RegisterPage.ts:

// frontend/src/pages/RegisterPage.ts

import { registerUser } from '../api/auth';

import { navigateTo } from '../router';

import { t } from '../i18n'; // t fonksiyonunu import et


export function render() {

  return `

    <div class="min-h-screen bg-gray-100 flex items-center justify-center">

      <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md">

        <h2 class="text-2xl font-bold mb-6 text-center">${t('register_title')}</h2>

        <form id="register-form">

          <div class="mb-4">

            <label for="name" class="block text-gray-700 text-sm font-bold mb-2">${t('name_label')}</label>

            <input type="text" id="name" name="name" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">

          </div>

          <div class="mb-4">

            <label for="email" class="block text-gray-700 text-sm font-bold mb-2">${t('email_label')}</label>

            <input type="email" id="email" name="email" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" required>

          </div>

          <div class="mb-6">

            <label for="password" class="block text-gray-700 text-sm font-bold mb-2">${t('password_label')}</label>

            <input type="password" id="password" name="password" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline" required>

          </div>

          <div class="flex items-center justify-between">

            <button type="submit" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">

              ${t('register_button')}

            </button>

            <a href="/" class="inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800" data-link>

              ${t('login_link')}

            </a>

          </div>

        </form>

      </div>

    </div>

  `;

}


// afterRender fonksiyonu aynı kalıyor

export function afterRender() {

  const form = document.querySelector<HTMLFormElement>('#register-form');

  if (form) {

    form.addEventListener('submit', async (e) => {

      e.preventDefault();

      const name = (form.querySelector('#name') as HTMLInputElement).value;

      const email = (form.querySelector('#email') as HTMLInputElement).value;

      const password = (form.querySelector('#password') as HTMLInputElement).value;


      try {

        await registerUser(email, password, name);

        alert(t('register_success_alert')); // Değiştirilen satır

        navigateTo('/'); // Giriş sayfasına yönlendir

      }

      catch (error: any)

      {

        // Backend'den gelen mesaja göre çeviri yap

        const errorMessage = error.message;

        if (errorMessage.includes('This email is already registered'))

          alert(t('error_email_registered'));

        else

          // Bilinmeyen diğer hatalar için genel mesaj

          alert(errorMessage);

      }

    });

  }

}






frontend/src/pages/router/index.ts:

// frontend/src/router/index.ts

import * as LoginPage from '../pages/LoginPage';

import * as RegisterPage from '../pages/RegisterPage';

import * as DashboardPage from '../pages/DashboardPage';

import * as LobbyPage from '../pages/LobbyPage';

import * as LocalGamePage from '../pages/LocalGamePage';

import * as OnlineGamePage from '../pages/OnlineGamePage';

import { connectSocket, getSocket } from '../socket';

import * as OnlineLobbyPage from '../pages/OnlineLobbyPage';

import * as ProfilePage from '../pages/ProfilePage';

import * as MatchHistoryPage from '../pages/MatchHistoryPage';


interface Route {

  render: () => string;

  afterRender?: () => void;

  cleanup?: () => void;

}

let currentRoute: Route | null = null;


const routes: { [key: string]: Route } = {

  '/': { render: LoginPage.render, afterRender: LoginPage.afterRender },

  '/register': { render: RegisterPage.render, afterRender: RegisterPage.afterRender },

  '/dashboard': { render: DashboardPage.render, afterRender: DashboardPage.afterRender, cleanup: DashboardPage.cleanup },

  '/lobby': { render: LobbyPage.render, afterRender: LobbyPage.afterRender },

  '/online-lobby': { render: OnlineLobbyPage.render, afterRender: OnlineLobbyPage.afterRender },

  '/local-game': { render: LocalGamePage.render, afterRender: LocalGamePage.afterRender, cleanup: LocalGamePage.cleanup },

  '/online-game': { render: OnlineGamePage.render, afterRender: OnlineGamePage.afterRender, cleanup: OnlineGamePage.cleanup },

};


const app = document.querySelector<HTMLDivElement>('#app')!;


// frontend/src/router/index.ts


export async function handleLocation() {

  const path = window.location.pathname;

  const token = localStorage.getItem('token');


  // 1. ADIM: Gerekliyse soket bağlantısını kur ve bekle.

  if (token) {

    if (!getSocket() || !getSocket()?.connected) {

      try {

        await connectSocket(token);

      } catch (error) {

        console.error("Soket'e bağlanılamadı, çıkış yapılıyor.");

        localStorage.removeItem('token');

        navigateTo('/');

        return;

      }

    }

  }


  // 2. ADIM: Yönlendirme kurallarını uygula.

  const protectedPaths = ['/dashboard', '/lobby', '/online-lobby', '/local-game', '/online-game'];

  const isAuthRequired = protectedPaths.includes(path);


  if (isAuthRequired && !token) {

    if (path !== '/') navigateTo('/');

    return;

  }

  if (!isAuthRequired && token && (path === '/' || path === '/register')) {

    navigateTo('/dashboard');

    return;

  }


  // 3. ADIM: Sayfayı render et.

  let routeToRender: Route | null = null;

  

  if (path.startsWith('/profile/') && path.endsWith('/history')) {

    routeToRender = MatchHistoryPage;

  } else if (path.startsWith('/profile/')) {

    routeToRender = ProfilePage;

  } else {

    routeToRender = routes[path] || routes['/'];

  }

  

  if (!routeToRender) {

      app.innerHTML = '<h1>404 Not Found</h1>';

      return;

  }


  // Sadece rota gerçekten değiştiyse render et

  if (currentRoute !== routeToRender) {

    if (currentRoute && currentRoute.cleanup) {

      currentRoute.cleanup();

    }

    

    app.innerHTML = routeToRender.render();

    

    if (routeToRender.afterRender) {

      void routeToRender.afterRender();

    }

    currentRoute = routeToRender;

  }

}



export async function navigateTo(path: string) { // 'async' eklendi

  window.history.pushState({}, '', path);

  await handleLocation(); // 'await' eklendi

}



export async function initializeRouter() { // 'async' eklendi

  window.addEventListener('popstate', () => handleLocation()); // Olası "this" context hatalarını önlemek için arrow function içine aldık.

  document.body.addEventListener('click', (e: MouseEvent) => {

    const target = e.target as HTMLElement;

    if (target.matches('[data-link]')) {

      e.preventDefault();

      void navigateTo(target.getAttribute('href')!); // 'void' eklendi

    }

  });

  await handleLocation(); // 'await' eklendi

}






frontend/src/chatState.ts:

// frontend/src/chatState.ts


interface ChatMessage {

  type: 'public' | 'private';

  sender: string;

  content: string;

}


const STORAGE_KEY = 'chat_messages_v2'; // Veri yapısı değiştiği için anahtarı güncelleyelim


let messages: ChatMessage[] = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || '[]');


export function addMessage(message: ChatMessage) {

  messages.push(message);

  sessionStorage.setItem(STORAGE_KEY, JSON.stringify(messages));

}


export function getMessages(): ChatMessage[] {

  return messages;

}


export function clearMessages() {

  messages = [];

  sessionStorage.removeItem(STORAGE_KEY);

}






frontend/src/i18n.ts:

// frontend/src/i18n.ts


// Dil dosyalarını import ediyoruz.

import en from './locales/en.json';

import tr from './locales/tr.json';

import ru from './locales/ru.json';


const translations: { [key: string]: any } = { en, tr, ru };


let currentLanguage: string;

let currentTranslations: any;


function getLanguage(): string {

  // Kullanıcının daha önce seçtiği dil localStorage'da var mı diye bak.

  const savedLang = localStorage.getItem('language');

  // Yoksa, tarayıcının dilini al, o da desteklenmiyorsa İngilizce'ye ayarla.

  const browserLang = navigator.language.split('-')[0];

  return savedLang || (translations[browserLang] ? browserLang : 'en');

}


export function setLanguage(lang: string) {

  currentLanguage = lang;

  currentTranslations = translations[lang];

  localStorage.setItem('language', lang);

}


export function getCurrentLanguage(): string {

  return currentLanguage;

}


// Çeviri fonksiyonumuz (t kısaltmasıyla kullanılır: "translate")

export function t(key: string): string {

  if (Object.prototype.hasOwnProperty.call(currentTranslations, key)) {

    return currentTranslations[key];

  }

  return key;

}


// Uygulama ilk yüklendiğinde dili ayarla.

setLanguage(getLanguage());






frontend/src/main.ts:

import './style.css';

// handleLocation'ı import etmeye artık gerek yok

import { initializeRouter } from './router'; 

import { setLanguage, getCurrentLanguage } from './i18n';


document.addEventListener('DOMContentLoaded', () => {

  

  const currentLangBtn = document.getElementById('current-lang-btn');

  const currentLangText = document.getElementById('current-lang-text');

  const langOptions = document.getElementById('lang-options');


  // Sayfa yüklendiğinde mevcut dili butona yaz

  if (currentLangText) {

    currentLangText.textContent = getCurrentLanguage().toUpperCase();

  }


  // Ana butona tıklayınca menüyü aç/kapat

  currentLangBtn?.addEventListener('click', (e) => {

    e.stopPropagation();

    langOptions?.classList.toggle('hidden');

  });


  // Seçeneklerden birine tıklayınca dili değiştir

  langOptions?.addEventListener('click', (e) => {

    e.preventDefault();

    const target = e.target as HTMLElement;

    const lang = target.getAttribute('data-lang');

    if (lang) {

      setLanguage(lang);

      window.location.reload();

    }

  });


  // Menü açıkken dışarıya tıklayınca kapat

  window.addEventListener('click', () => {

    if (!langOptions?.classList.contains('hidden')) {

      langOptions?.classList.add('hidden');

    }

  });


  void initializeRouter();

});






frontend/src/socket.ts:

// frontend/src/socket.ts

import { io, Socket } from "socket.io-client";


let socket: Socket | null = null;


// frontend/src/socket.ts -> connectSocket fonksiyonu


export function connectSocket(token: string): Promise<Socket> {

    return new Promise((resolve, reject) => {

        if (socket && socket.connected) {

            return resolve(socket);

        }


        const SOCKET_URL = `http://${window.location.hostname}:3000`;

        const newSocket = io(SOCKET_URL, {

            auth: { token }

        });


        newSocket.on('connect', () => {

            console.log('Socket sunucuya başarıyla bağlandı! ID:', newSocket.id);

            socket = newSocket;

            resolve(newSocket);

        });


        // --- YENİ EKLENECEK DİNLEYİCİ ---

        newSocket.on('forceDisconnect', (reason) => {

            console.log(`Sunucu tarafından bağlantı sonlandırıldı: ${reason}`);

            alert('Başka bir konumdan giriş yapıldığı için bu oturum sonlandırıldı.');

            

            // Yerel durumu temizle

            localStorage.removeItem('token');

            // 'disconnectSocket' fonksiyonu socket'i null yapar ve bağlantıyı kapatır.

            disconnectSocket(); 

            // Kullanıcıyı login sayfasına yönlendir. Sayfa yenilemesi en garanti yöntemdir.

            window.location.href = '/'; 

        });

        // --- YENİ BLOĞUN SONU ---


        newSocket.on('disconnect', () => {

            console.log('Socket bağlantısı kesildi. Yeniden bağlanmaya çalışılıyor...');

        });


        newSocket.on('connect_error', (err) => {

            console.error('Socket bağlantı hatası:', err.message);

            reject(err);

        });

    });

}


// getSocket ve disconnectSocket fonksiyonları aynı kalabilir.

export function getSocket(): Socket | null {

    return socket;

}


export function disconnectSocket() {

    if (socket) {

        socket.disconnect();

        socket = null;

    }

}






frontend/src/style.css:

/* frontend/src/style.css */

@tailwind base;

@tailwind components;

@tailwind utilities;






frontend/src/utils.ts:

// frontend/src/utils.ts


// JWT'yi çözen yardımcı fonksiyon

export function jwt_decode(token: string): any {

    try {

        return JSON.parse(atob(token.split('.')[1]));

    } catch (e) {

        return null;

    }

}






frontend/src/vite-env.d.ts:

/// <reference types="vite/client" />






frontend/.gitignore:

# Logs

logs

*.log

npm-debug.log*

yarn-debug.log*

yarn-error.log*

pnpm-debug.log*

lerna-debug.log*


node_modules

dist

dist-ssr

*.local


# Editor directories and files

.vscode/*

!.vscode/extensions.json

.idea

.DS_Store

*.suo

*.ntvs*

*.njsproj

*.sln

*.sw?






frontend/Dockerfile:

# frontend/Dockerfile

FROM node:20


WORKDIR /usr/src/app


COPY package*.json ./

RUN npm install


COPY . .


EXPOSE 5173


CMD ["npm", "run", "dev"]






frontend/index.html:

<!DOCTYPE html>

<html lang="en">

  <head>

    <meta charset="UTF-8" />

    <link rel="icon" type="image/svg+xml" href="/vite.svg" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Transcendence</title>

  </head>

  <body>


    <div class="fixed top-0 left-0 p-4 z-50">

      <div class="relative" id="lang-dropdown">

        <button id="current-lang-btn" class="flex items-center space-x-2 bg-gray-700 text-white px-3 py-2 rounded-md hover:bg-gray-600">

          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9V3m0 18a9 9 0 009-9m-9 9a9 9 0 00-9-9"></path></svg>

          <span id="current-lang-text">EN</span>

          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>

        </button>

        <div id="lang-options" class="hidden absolute left-0 mt-2 w-full bg-gray-700 rounded-md shadow-lg">

          <a href="#" data-lang="tr" class="block px-4 py-2 text-sm text-white hover:bg-gray-600">Türkçe</a>

          <a href="#" data-lang="en" class="block px-4 py-2 text-sm text-white hover:bg-gray-600">English</a>

          <a href="#" data-lang="ru" class="block px-4 py-2 text-sm text-white hover:bg-gray-600">Русский</a>

        </div>

      </div>

    </div>

    

    <div id="app"></div>

    <script type="module" src="/src/main.ts"></script>

  </body>

</html>






frontend/package.json:

{

  "name": "frontend",

  "private": true,

  "version": "0.0.0",

  "type": "module",

  "scripts": {

    "dev": "vite --host",

    "build": "tsc && vite build",

    "preview": "vite preview"

  },

  "devDependencies": {

    "autoprefixer": "^10.4.21",

    "postcss": "^8.5.6",

    "tailwindcss": "^3.4.17",

    "typescript": "~5.8.3",

    "vite": "^7.1.2"

  },

  "dependencies": {

    "socket.io-client": "^4.8.1"

  }

}






frontend/postcss.config.js:

export default {

  plugins: {

    tailwindcss: {},

    autoprefixer: {},

  },

}






frontend/tailwind.config.js:

/** @type {import('tailwindcss').Config} */

export default {

  content: [

    "./index.html",

    "./src/**/*.{js,ts,jsx,tsx}",

  ],

  theme: {

    extend: {},

  },

  plugins: [],

}






frontend/tsconfig.json:

{

  "compilerOptions": {

    "target": "ES2022",

    "useDefineForClassFields": true,

    "module": "ESNext",

    "lib": ["ES2022", "DOM", "DOM.Iterable"],

    "skipLibCheck": true,


    /* Bundler mode */

    "moduleResolution": "bundler",

    "allowImportingTsExtensions": true,

    "verbatimModuleSyntax": true,

    "moduleDetection": "force",

    "noEmit": true,


    /* Linting */

    "strict": true,

    "noUnusedLocals": true,

    "noUnusedParameters": true,

    "erasableSyntaxOnly": true,

    "noFallthroughCasesInSwitch": true,

    "noUncheckedSideEffectImports": true,

    "forceConsistentCasingInFileNames": true

  },

  "include": ["src"]

}



